// Generated by CoffeeScript 1.6.2
(function() {
  var __slice = [].slice;

  $(function() {
    var navigation;

    return navigation = responsiveNav("#nav", {
      label: "list",
      openPos: "static"
    });
  });

  angular.module('components', []).directive('tabs', function() {
    return {
      restrict: 'E',
      transclude: true,
      scope: {},
      controller: function($scope, $element) {
        var panes;

        panes = $scope.panes = [];
        $scope.select = function(pane) {
          angular.forEach(panes, function(pane) {
            return pane.selected = false;
          });
          return pane.selected = true;
        };
        return this.addPane = function(pane) {
          if (panes.length === 0) {
            $scope.select(pane);
          }
          return panes.push(pane);
        };
      },
      template: '<div class="tabs">\n  <ul class="tab-bar">\n    <li ng-repeat="pane in panes" class="tab-bar__tab">\n      <a href="" class="tab-bar__link" ng-class="{\'is-active\':pane.selected}" ng-click="select(pane)">{{pane.title}}</a>\n    </li>\n  </ul>\n  <div class="tab-content" ng-transclude></div>\n</div>',
      replace: true
    };
  }).directive('pane', function() {
    return {
      require: '^tabs',
      restrict: 'E',
      transclude: true,
      scope: {
        title: '@'
      },
      link: function(scope, element, attrs, tabsCtrl) {
        return tabsCtrl.addPane(scope);
      },
      template: '<div class="tab-pane" ng-class="{\'is-active\': selected}" ng-transclude>\n</div>',
      replace: true
    };
  }).factory("hashchange", function($rootScope) {
    var last_hash;

    last_hash = window.location.hash;
    return {
      on: function(cb) {
        console.log("on hashchange");
        return setInterval(function() {
          if (last_hash !== window.location.hash) {
            console.log("onHashChange", window.location.hash);
            last_hash = window.location.hash;
            return $rootScope.$apply(function() {
              return typeof cb === "function" ? cb(last_hash) : void 0;
            });
          }
        }, 100);
      }
    };
  }).factory("socket", function($rootScope) {
    var socket;

    socket = io.connect();
    console.log("connected?");
    return {
      on: function(event, cb) {
        return socket.on(event, function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return $rootScope.$apply(function() {
            return cb.apply(socket, args);
          });
        });
      },
      emit: function(event, data, ack) {
        if (typeof data === "function") {
          ack = data;
          data = "";
        }
        return socket.emit(event, data, function() {
          var args;

          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          return $rootScope.$apply(function() {
            return ack != null ? ack.apply(socket, args) : void 0;
          });
        });
      }
    };
  }).controller('AppCtrl', function($scope, socket, hashchange) {
    var add_or_update_channel, first_connection, update_channel_state;

    first_connection = true;
    $scope.channels = [];
    $scope.current_channels = [];
    $scope.$watch("channels", function(n, o) {
      return console.log("channels, n", n, "o", o);
    }, true);
    add_or_update_channel = function(room) {
      var chan;

      if (chan = _($scope.channels).find(function(chan) {
        return chan.name === room.name;
      })) {
        return chan.users = room.users;
      } else {
        return $scope.channels.push(room);
      }
    };
    update_channel_state = function(name, state) {
      var chan, k, v, _results;

      if (chan = _($scope.channels).find(function(chan) {
        return chan.name === name;
      })) {
        _results = [];
        for (k in state) {
          v = state[k];
          _results.push(chan[k] = v);
        }
        return _results;
      }
    };
    socket.on("connect", function() {
      var current_channel,
        _this = this;

      $scope.$watch("current_channels", function(new_arr, old_arr) {
        var chan, _i, _j, _len, _len1, _ref, _ref1, _results;

        console.log("currents_channels", new_arr, old_arr);
        if (new_arr === old_arr) {
          old_arr = [];
        }
        _ref = _(new_arr).difference(old_arr);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          chan = _ref[_i];
          console.log("Joining " + chan);
          socket.emit("join", chan, function(users) {
            console.log("Users in " + chan, users.length);
            return update_channel_state(chan, {
              joined: true
            });
          });
        }
        console.log("leave", _(old_arr).difference(new_arr));
        _ref1 = _(old_arr).difference(new_arr);
        _results = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          chan = _ref1[_j];
          console.log("Leaving " + chan);
          socket.emit("leave", chan);
          _results.push(update_channel_state(chan, {
            joined: false
          }));
        }
        return _results;
      }, true);
      hashchange.on(current_channel = function(hash) {
        console.log("new hash", (hash != null ? hash : window.location.hash).split(/\#/).slice(1));
        return $scope.current_channels = (hash != null ? hash : window.location.hash).split(/\#/).slice(1);
      });
      current_channel();
      if (!first_connection) {
        window.location.reload();
      }
      first_connection = false;
      return socket.emit("me", {
        username: "Anon" + (Math.round(Math.random() * 90000) + 10000),
        avatar: "",
        userAgent: navigator.userAgent
      }, function() {
        return socket.emit("list_rooms", function(rooms) {
          var room, _i, _len, _results;

          console.log("list_rooms", rooms);
          _results = [];
          for (_i = 0, _len = rooms.length; _i < _len; _i++) {
            room = rooms[_i];
            _results.push(add_or_update_channel(room));
          }
          return _results;
        });
      });
    });
    return socket.on("room_update", function(room) {
      console.log("room_update", room);
      return add_or_update_channel(room);
    });
  });

}).call(this);
